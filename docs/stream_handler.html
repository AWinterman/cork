<!DOCTYPE html>

<html>
<head>
  <title>Stream Handler</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="demi.html">
                demi.js
              </a>
            
              
              <a class="source" href="stream_handler.html">
                stream_handler.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1>Stream Handler</h1>
<p>A little module to handle a stream which corresponds to each user defined
route in Cork. </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>module.exports = StreamHandler

<span class="keyword">var</span> Stream = require(<span class="string">"stream"</span>)


<span class="function"><span class="keyword">function</span> <span class="title">StreamHandler</span><span class="params">()</span>{</span>
  <span class="keyword">this</span>.stream = <span class="keyword">new</span> Stream
}

<span class="keyword">var</span> proto = StreamHandler.prototype
  , cons = StreamHandler
proto.constructor = cons</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p><strong> <code>.on(name, callback, mimetype)</code> </strong></p>
<p><code>name</code> is a string with the name of the event to be handled. Expects HTTP
methods</p>
<p><code>callback(req)</code> is a function of the
<a href="http://nodejs.org/api/http.html#http_http_incomingmessage">http.IncomingMessage</a>
object representing the clients request. This might be a little blunt, but
allows the user to respond to url parameters, headers, or the body of the
request as they see fit. Of course they can also ignore the request object
entirely, which would be roughly equivalent to the way Flask handles things
by default.</p>
<p><code>response_headers</code> is a function of a
<a href="http://nodejs.org/api/http.html#http_http_incomingmessage">http.IncomingMessage</a>
object representing the incoming request.  It is an optional argument-- If
supplied it will be evaluated and included in the response header.</p>
<p>Finally, <code>.on</code> returns proto, so you can chain <code>on</code> definitions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>proto.on = <span class="keyword">function</span>(name, callback, response_headers){
  <span class="keyword">var</span> current_listeners = <span class="keyword">this</span>.stream.listeners(name)
  <span class="keyword">if</span> (current_listeners){
    <span class="keyword">this</span>.stream.removeAllListeners(name)
  }
  <span class="keyword">this</span>.stream.on(name, framework_for_response.call(<span class="keyword">this</span>, callback, response_headers))
  <span class="keyword">return</span> <span class="keyword">this</span>
}</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p><strong> <code>framework_for_response</code> </strong>
This private function wraps up the user-supplied <code>callback</code> in a function which handles
emmitting a <code>data</code> event with the response string and a <code>headers</code> event for
the the response_headers object. It is meant to be called with
`framework_for_response.call(stream, callback, response_headers)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">framework_for_response</span><span class="params">(callback, response_headers)</span>{</span>
  response_headers = response_headers || <span class="keyword">function</span>(x){ <span class="keyword">return</span> x }
  <span class="keyword">var</span> self = <span class="keyword">this</span>
  <span class="keyword">return</span> <span class="keyword">function</span>(req) {
    <span class="keyword">var</span> str = callback(req)
    self.stream.emit(<span class="string">"headers"</span>, response_headers(req))
    <span class="keyword">if</span> (callback) self.stream.emit(<span class="string">"data"</span>, str)
    self.stream.emit(<span class="string">"end"</span>)
  }
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
