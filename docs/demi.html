<!DOCTYPE html>

<html>
<head>
  <title>Demi</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="demi.html">
                demi.js
              </a>
            
              
              <a class="source" href="stream_handler.html">
                stream_handler.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1>Demi</h1>
<h4>Demi is a micro-framework for javascript based on flask.</h4>
<p>It implements a nice api which was inspired by flask&#39;s use of decorator
expressions. It is still a work in progress, so feel free to pitchin.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>module.exports = Demi

<span class="keyword">var</span> StreamHandler = require(<span class="string">'./stream_handler'</span>)
  , http = require(<span class="string">"http"</span>)
  , url = require(<span class="string">"url"</span>)
  , Stream = require(<span class="string">"stream"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Initialize Demi with an array of routes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">Demi</span><span class="params">(static_root)</span>{</span>
  <span class="keyword">this</span>.static_root = static_root
  <span class="keyword">this</span>.routes = []
}



<span class="keyword">var</span> proto = Demi.prototype
  , cons = Demi
proto.constructor = cons</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2>Methods</h2>
<p>** <code>.route(route)</code>
This method takes a route, and instantiates a StreamHandler to handle
requests emitted to the route. Returns the route so that the user can define
accompanying methods. </p>
<p>Note that the user <em>can</em> implement multiple listeners for the same route,
in which case the last one defined will override the others. This shouldn&#39;t
be encouraged-- old routes will not be deleted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>proto.route = <span class="keyword">function</span>(){</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>duplicates are okay, but order matters.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> routes = [].slice.call(arguments)
    , new_route = <span class="keyword">new</span> StreamHandler 
  <span class="keyword">this</span>.routes.push({regexen: routes, response: new_route})
  <span class="keyword">return</span> new_route
}</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>** <code>.get(pathname)</code>
This finds the a route matching a pathname (as defined
<a href="http://nodejs.org/docs/latest/api/url.html#url_url">here</a> if it can.
Otherwise it returns a stream that only emits 404 events</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>proto.get = <span class="keyword">function</span>(pathname){</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Descends so later routes overrride earlier routes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> target 
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">this</span>.routes.length -<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i){
    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, len = <span class="keyword">this</span>.routes[i].regexen.length; j &lt; len; ++j){
      <span class="keyword">if</span> (<span class="keyword">new</span> RegExp(<span class="keyword">this</span>.routes[i].regexen[j]).test(pathname)) {
        target = <span class="keyword">this</span>.routes[i].response
        <span class="keyword">break</span>
      }
    }
  }
  <span class="keyword">return</span> target
}</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>** <code>.run(port)</code></p>
<p> Starts up an http server. This handles the events emitted by
 <a href="./stream_handler.js">StreamHandler</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>proto.run = <span class="keyword">function</span>(port){
  <span class="keyword">var</span> self = <span class="keyword">this</span>
    , server = http.createServer(demi_server)

  <span class="function"><span class="keyword">function</span> <span class="title">demi_server</span><span class="params">(req, resp)</span> {</span>
    <span class="keyword">var</span> parsed = url.parse(req.url, <span class="literal">true</span>)
      , pathname = parsed.pathname
      , query = parsed.query || {}
      , stream

    response_stream = self.get(pathname)

    <span class="keyword">if</span> (!response_stream) {
      resp.writeHead(<span class="number">404</span>, {<span class="string">'content-type'</span>: <span class="string">'text/plain'</span>})
      process.nextTick(<span class="keyword">function</span>(){ resp.end(<span class="string">"blergh blergh blergh"</span>)})
    } <span class="keyword">else</span> {
      response_stream.stream
        .on(<span class="string">"headers"</span>, <span class="keyword">function</span>(headers){
          resp.writeHead(<span class="number">200</span>, headers)
        })
        .on(<span class="string">"data"</span>, <span class="keyword">function</span>(data){
          +resp.write(data)
        })
        .on(<span class="string">"end"</span>, <span class="keyword">function</span>(data){
          resp.end(data)
        })

      response_stream.stream.emit(req.method, req)
    }
  }

  server.listen(port)
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
