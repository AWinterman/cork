<!DOCTYPE html>

<html>
<head>
  <title>Demi</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="docs-example.html">
                docs-example.js
              </a>
            
              
              <a class="source" href="demi.html">
                demi.js
              </a>
            
              
              <a class="source" href="stream_handler.html">
                stream_handler.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1>Demi</h1>
<h4>Demi is a micro-framework for javascript based on <a href="http://flask.pocoo.org/">flask</a>.</h4>
<p>It implements a nice api which was inspired by flask&#39;s use of decorator
expressions. It is still a work in progress, so feel free to pitchin.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>module.exports = Demi

<span class="keyword">var</span> StreamHandler = require(<span class="string">'./stream_handler'</span>)
  , http = require(<span class="string">"http"</span>)
  , url = require(<span class="string">"url"</span>)
  , Stream = require(<span class="string">"stream"</span>)
  , static = require(<span class="string">'node-static'</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Initialize Demi with an array of routes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">Demi</span><span class="params">(static_root)</span>{</span>
  <span class="keyword">this</span>.file = <span class="keyword">new</span> (static.Server)(static_root)
  <span class="keyword">this</span>.routes = []
}



<span class="keyword">var</span> proto = Demi.prototype
  , cons = Demi
proto.constructor = cons</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2>Methods</h2>
<p><strong> <code>.route(route)</code> </strong>
This method takes a route, and instantiates a StreamHandler to handle
requests emitted to the route. Returns the route so that the user can define
accompanying methods. </p>
<p>Note that the user <em>can</em> implement multiple listeners for the same route,
in which case the last one defined will override the others. This shouldn&#39;t
be encouraged-- old routes will not be deleted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>proto.route = <span class="keyword">function</span>(){</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>duplicates are okay, but order matters.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> new_route = <span class="keyword">new</span> StreamHandler
  <span class="keyword">var</span> routes = [].slice.call(arguments)
  <span class="keyword">this</span>.routes.push({regexen: routes, responder: new_route})
  <span class="keyword">return</span> new_route
}</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p><strong> <code>.get(pathname)</code></strong> 
This finds the a route matching a pathname (as defined
<a href="http://nodejs.org/docs/latest/api/url.html#url_url">here</a> if it can.
Otherwise it returns a stream that only emits 404 events</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>proto.get = <span class="keyword">function</span>(pathname){</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Descends so later routes overrride earlier routes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> responder = <span class="literal">null</span>
    , embedded_args = []
    , regex
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">this</span>.routes.length -<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i){
    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, len = <span class="keyword">this</span>.routes[i].regexen.length; j &lt; len; ++j){
      regex = <span class="keyword">new</span> RegExp(<span class="keyword">this</span>.routes[i].regexen[j])
      <span class="keyword">if</span> (regex.test(pathname)) {
        responder = <span class="keyword">this</span>.routes[i].responder
        embedded_args = regex.exec(pathname).shift()
        <span class="keyword">break</span>
      }
    }
  }
  <span class="keyword">return</span> [responder, embedded_args]
}</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p><strong> <code>.run(port)</code> </strong></p>
<p> Starts up an http server. This handles the events emitted by
 <a href="./stream_handler.js">StreamHandler</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>proto.run = <span class="keyword">function</span>(port){
  console.log(<span class="string">"running on port: "</span> + port)
  <span class="keyword">var</span> self = <span class="keyword">this</span>
    , server = http.createServer(demi_server)

  <span class="function"><span class="keyword">function</span> <span class="title">demi_server</span><span class="params">(req, resp)</span> {</span>
    <span class="keyword">var</span> parsed = url.parse(req.url, <span class="literal">true</span>)
      , pathname = parsed.pathname
      , query = parsed.query || {}
      , stream

    <span class="keyword">var</span> responder = self.get(pathname)
    <span class="keyword">if</span> (!responder[<span class="number">0</span>]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>then look the the file in the static files</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      req.on(<span class="string">"end"</span>, <span class="keyword">function</span>() {
        self.file.serve(req, resp)
      })
      <span class="keyword">return</span>
    } <span class="keyword">else</span> {
      responder[<span class="number">0</span>].stream
        .on(<span class="string">"headers"</span>, <span class="keyword">function</span>(headers){
          resp.writeHead(<span class="number">200</span>, headers(responder[<span class="number">1</span>]))
        })
        .on(<span class="string">"data"</span>, <span class="keyword">function</span>(data){
          <span class="string">""</span>+resp.write(data(responder[<span class="number">1</span>]))
        })
        .on(<span class="string">"end"</span>, <span class="keyword">function</span>(cleanup){
          resp.end(cleanup(responder[<span class="number">1</span>]))
        })</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>may eventually want to allow cleanup on the end event, yet a third
argument to the .on method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      responder[<span class="number">0</span>].stream.emit(req.method, req)
    }
  }

  server.listen(port)
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
